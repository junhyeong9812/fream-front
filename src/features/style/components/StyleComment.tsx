import React, {
  useState,
  useEffect,
  useContext,
  useRef,
  useCallback,
} from "react";
import ReactDOM from "react-dom";
import { Heart, X } from "lucide-react";
import { formatRelativeTime } from "src/global/utils/timeUtils";
import { AuthContext } from "src/global/context/AuthContext";
import LoginModal from "../../common/components/LoginModal";
import styleCommentService from "../services/StyleCommentService";
import styleCommentLikeService from "../services/StyleCommentLikeService";
import {
  StyleCommentResponseDto,
  AddCommentRequestDto,
} from "../types/styleTypes";
import styles from "./StyleComment.module.css";

interface StyleCommentProps {
  isOpen: boolean;
  onClose: () => void;
  styleId: number;
  styleContent: string;
  styleCreatedDate: string;
  authorProfileName: string;
  authorProfileImage: string;
}

const StyleComment: React.FC<StyleCommentProps> = ({
  isOpen,
  onClose,
  styleId,
  styleContent,
  styleCreatedDate,
  authorProfileName,
  authorProfileImage,
}) => {
  const [comments, setComments] = useState<StyleCommentResponseDto[]>([]);
  const [commentText, setCommentText] = useState("");
  const [replyTo, setReplyTo] = useState<{ id: number; name: string } | null>(
    null
  );
  const [page, setPage] = useState(0);
  const [hasMore, setHasMore] = useState(true);
  const [totalComments, setTotalComments] = useState(0);
  const [isLoading, setIsLoading] = useState(false);
  const [isLoadingMore, setIsLoadingMore] = useState(false);
  const [isLoginModalOpen, setLoginModalOpen] = useState(false);
  const [userProfileImage, setUserProfileImage] = useState<string | null>(null);
  const [shouldShowCommentModal, setShouldShowCommentModal] = useState(false);
  const { isLoggedIn } = useContext(AuthContext);
  const commentInputRef = useRef<HTMLInputElement>(null);
  const modalRef = useRef<HTMLDivElement>(null);
  const commentsContainerRef = useRef<HTMLDivElement>(null);

  // ÏòàÏãú ÌÄµ Î¶¨ÌîåÎùºÏù¥ ÌÖçÏä§Ìä∏
  const quickReplies = [
    "Ï¢ãÏïÑÏöî ‚ù§Ô∏è",
    "ÎßûÌåîÌï¥Ïöî üòÄ",
    "Ï†ïÎ≥¥ Î∂ÄÌÉÅÌï¥Ïöî üôè",
    "ÌèâÏÜå ÏÇ¨Ïù¥Ï¶àÍ∞Ä Í∂ÅÍ∏àÌï¥Ïöî üëÄ",
  ];

  // isOpen Í∞íÏù¥ Î≥ÄÍ≤ΩÎêòÎ©¥ Î°úÍ∑∏Ïù∏ ÏÉÅÌÉú ÌôïÏù∏
  useEffect(() => {
    if (isOpen) {
      if (!isLoggedIn) {
        // Î°úÍ∑∏Ïù∏ÎêòÏñ¥ ÏûàÏßÄ ÏïäÏúºÎ©¥ Î°úÍ∑∏Ïù∏ Î™®Îã¨ ÌëúÏãú
        setLoginModalOpen(true);
        // ÎåìÍ∏Ä Î™®Îã¨ÏùÄ ÌëúÏãúÌïòÏßÄ ÏïäÏùå
        setShouldShowCommentModal(false);
      } else {
        // Î°úÍ∑∏Ïù∏ÎêòÏñ¥ ÏûàÏúºÎ©¥ ÎåìÍ∏Ä Î™®Îã¨ ÌëúÏãú
        setShouldShowCommentModal(true);
        setLoginModalOpen(false);
        // ÎåìÍ∏Ä Îç∞Ïù¥ÌÑ∞ Î°úÎìú
        setPage(0);
        setComments([]);
        setHasMore(true);
        fetchComments(0, true);
      }
    } else {
      // Î™®Îã¨Ïù¥ Îã´ÌûàÎ©¥ ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
      setShouldShowCommentModal(false);
      setLoginModalOpen(false);
    }
  }, [isOpen, isLoggedIn, styleId]);

  // Î°úÍ∑∏Ïù∏ Î™®Îã¨ Îã´Ìûê Îïå Ï≤òÎ¶¨
  const handleLoginModalClose = () => {
    setLoginModalOpen(false);
    // Î°úÍ∑∏Ïù∏ Î™®Îã¨Ïù¥ Îã´ÌûàÍ≥† Î°úÍ∑∏Ïù∏ ÎêòÏñ¥ ÏûàÏúºÎ©¥ ÎåìÍ∏Ä Î™®Îã¨ ÌëúÏãú
    if (isLoggedIn) {
      setShouldShowCommentModal(true);
      // ÎåìÍ∏Ä Îç∞Ïù¥ÌÑ∞ Î°úÎìú
      setPage(0);
      setComments([]);
      setHasMore(true);
      fetchComments(0, true);
    } else {
      // Î°úÍ∑∏Ïù∏ ÎêòÏñ¥ ÏûàÏßÄ ÏïäÏúºÎ©¥ Î∂ÄÎ™® Ïª¥Ìè¨ÎÑåÌä∏Ïùò onClose Ìò∏Ï∂ú
      onClose();
    }
  };

  // Î™®Îã¨ Ïô∏Î∂Ä ÌÅ¥Î¶≠ Ïãú Îã´Í∏∞
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (
        modalRef.current &&
        !modalRef.current.contains(event.target as Node)
      ) {
        onClose();
      }
    };

    if (shouldShowCommentModal) {
      document.addEventListener("mousedown", handleClickOutside);
    }

    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, [shouldShowCommentModal, onClose]);

  // Î¨¥Ìïú Ïä§ÌÅ¨Î°§ Íµ¨ÌòÑ
  const handleScroll = useCallback(() => {
    if (!commentsContainerRef.current || isLoadingMore || !hasMore) return;

    const { scrollTop, scrollHeight, clientHeight } =
      commentsContainerRef.current;
    if (scrollTop + clientHeight >= scrollHeight - 100) {
      // Ïä§ÌÅ¨Î°§Ïù¥ Í±∞Ïùò Î∞îÎã•Ïóê ÎèÑÎã¨ÌïòÎ©¥ Îã§Ïùå ÌéòÏù¥ÏßÄ Î°úÎìú
      const nextPage = page + 1;
      setPage(nextPage);
      fetchComments(nextPage, false);
    }
  }, [isLoadingMore, hasMore, page]);

  // Ïä§ÌÅ¨Î°§ Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà Îì±Î°ù
  useEffect(() => {
    const currentRef = commentsContainerRef.current;
    if (currentRef) {
      currentRef.addEventListener("scroll", handleScroll);
    }

    return () => {
      if (currentRef) {
        currentRef.removeEventListener("scroll", handleScroll);
      }
    };
  }, [handleScroll]);

  // ÎåìÍ∏Ä Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞
  const fetchComments = async (pageNumber: number, isInitialLoad: boolean) => {
    if (isInitialLoad) {
      setIsLoading(true);
    } else {
      setIsLoadingMore(true);
    }

    try {
      const response = await styleCommentService.getComments(
        styleId,
        pageNumber,
        10
      );

      setTotalComments(response.totalComments);

      // ÏÇ¨Ïö©Ïûê ÌîÑÎ°úÌïÑ Ïù¥ÎØ∏ÏßÄ ÏÑ§Ï†ï
      if (response.userProfileImageUrl) {
        setUserProfileImage(response.userProfileImageUrl);
      }

      if (isInitialLoad) {
        setComments(response.comments);
      } else {
        setComments((prev) => [...prev, ...response.comments]);
      }

      // Îçî Î∂àÎü¨Ïò¨ ÎåìÍ∏ÄÏù¥ ÏûàÎäîÏßÄ ÌôïÏù∏
      setHasMore(response.comments.length === 10);
    } catch (error) {
      console.error("Failed to fetch comments:", error);
    } finally {
      if (isInitialLoad) {
        setIsLoading(false);
      } else {
        setIsLoadingMore(false);
      }
    }
  };

  // ÎåìÍ∏Ä ÏûëÏÑ± Ìï®Ïàò
  const handlePostComment = async () => {
    if (!commentText.trim() || !isLoggedIn) return;

    try {
      const requestDto: AddCommentRequestDto = {
        styleId,
        content: commentText,
        parentCommentId: replyTo?.id,
      };

      await styleCommentService.addComment(requestDto);

      // ÎåìÍ∏Ä Ï∂îÍ∞Ä ÌõÑ Î™©Î°ù ÏÉàÎ°úÍ≥†Ïπ®
      setPage(0);
      fetchComments(0, true);

      // ÏûÖÎ†• ÌïÑÎìú Î∞è ÎãµÍ∏Ä ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
      setCommentText("");
      setReplyTo(null);
    } catch (error) {
      console.error("Failed to post comment:", error);
    }
  };

  // ÎãµÍ∏Ä ÏûëÏÑ± Î™®Îìú ÏÑ§Ï†ï
  const handleReplyClick = (commentId: number, userName: string) => {
    if (!isLoggedIn) {
      setLoginModalOpen(true);
      setShouldShowCommentModal(false);
      return;
    }

    setReplyTo({ id: commentId, name: userName });
    setCommentText(`@${userName} `);
    commentInputRef.current?.focus();
  };

  // ÎãµÍ∏Ä Î™®Îìú Ï∑®ÏÜå
  const cancelReplyMode = () => {
    setReplyTo(null);
    setCommentText("");
  };

  // ÎåìÍ∏Ä Ï¢ãÏïÑÏöî ÌÜ†Í∏Ä
  const handleToggleLike = async (commentId: number) => {
    if (!isLoggedIn) {
      setLoginModalOpen(true);
      setShouldShowCommentModal(false);
      return;
    }

    try {
      const success = await styleCommentLikeService.toggleCommentLike(
        commentId
      );

      if (success) {
        // Ï¢ãÏïÑÏöî ÏÉÅÌÉú Î°úÏª¨ÏóêÏÑú ÏóÖÎç∞Ïù¥Ìä∏
        setComments((prevComments) =>
          prevComments.map((comment) => {
            // Î£®Ìä∏ ÎåìÍ∏ÄÏù∏ Í≤ΩÏö∞
            if (comment.id === commentId) {
              const newLiked = !comment.liked;
              return {
                ...comment,
                liked: newLiked,
                likeCount: newLiked
                  ? comment.likeCount + 1
                  : comment.likeCount - 1,
              };
            }

            // ÎåÄÎåìÍ∏ÄÏù∏ Í≤ΩÏö∞
            if (comment.replies) {
              return {
                ...comment,
                replies: comment.replies.map((reply) => {
                  if (reply.id === commentId) {
                    const newLiked = !reply.liked;
                    return {
                      ...reply,
                      liked: newLiked,
                      likeCount: newLiked
                        ? reply.likeCount + 1
                        : reply.likeCount - 1,
                    };
                  }
                  return reply;
                }),
              };
            }

            return comment;
          })
        );
      }
    } catch (error) {
      console.error("Failed to toggle like:", error);
    }
  };

  // ÌÄµ Î¶¨ÌîåÎùºÏù¥ ÏÑ†ÌÉù
  const handleQuickReplyClick = (text: string) => {
    if (!isLoggedIn) {
      setLoginModalOpen(true);
      setShouldShowCommentModal(false);
      return;
    }
    setCommentText(text);
    commentInputRef.current?.focus();
  };

  // ÎåìÍ∏Ä ÏûÖÎ†•Ï∞Ω Ìè¨Ïª§Ïä§
  const handleCommentInputFocus = () => {
    if (!isLoggedIn) {
      setLoginModalOpen(true);
      setShouldShowCommentModal(false);
      return;
    }
  };

  // ÎåìÍ∏Ä Î™®Îã¨ ÏΩòÌÖêÏ∏† Ï†ïÏùò
  const commentModalContent = (
    <>
      <div
        className={`${styles.modalOverlay} ${
          shouldShowCommentModal ? "" : styles.modalOverlayHidden
        }`}
        onClick={onClose}
      />
      <div
        className={`${styles.commentModal} ${
          shouldShowCommentModal ? styles.commentModalOpen : ""
        }`}
        ref={modalRef}
      >
        <div className={styles.modalHeader}>
          <h2 className={styles.title}>ÎåìÍ∏Ä</h2>
          <button className={styles.closeButton} onClick={onClose}>
            <X size={24} />
          </button>
        </div>

        <div className={styles.commentTop}>
          <div className={styles.authorComment}>
            <div className={styles.profileImage}>
              <img
                src={authorProfileImage || "/api/placeholder/40/40"}
                alt="ÌîÑÎ°úÌïÑ"
              />
            </div>
            <div className={styles.commentContent}>
              <div className={styles.profileName}>{authorProfileName}</div>
              <div className={styles.content}>{styleContent}</div>
              <div className={styles.timeStamp}>
                {formatRelativeTime(styleCreatedDate)}
              </div>
            </div>
          </div>
        </div>

        {/* ÎåìÍ∏Ä ÏûÖÎ†• ÏòÅÏó≠ÏùÑ ÏÉÅÎã®ÏúºÎ°ú Ïù¥Îèô */}
        <div className={styles.inputSection}>
          {replyTo && (
            <div className={styles.replyIndicator}>
              <span>
                <b>{replyTo.name}</b>ÎãòÏóêÍ≤å ÎãµÍ∏Ä ÏûëÏÑ± Ï§ë
              </span>
              <button
                className={styles.cancelReplyButton}
                onClick={cancelReplyMode}
              >
                Ï∑®ÏÜå
              </button>
            </div>
          )}

          <div className={styles.profileImage}>
            <img
              src={
                isLoggedIn && userProfileImage
                  ? userProfileImage
                  : "/api/placeholder/40/40"
              }
              alt="ÌîÑÎ°úÌïÑ"
            />
          </div>
          <div style={{ flex: 1 }}>
            <div className={styles.quickReplyContainer}>
              {quickReplies.map((text, index) => (
                <button
                  key={index}
                  className={styles.quickReplyButton}
                  onClick={() => handleQuickReplyClick(text)}
                >
                  {text}
                </button>
              ))}
            </div>
            <div className={styles.inputBox}>
              <input
                className={styles.commentInput}
                ref={commentInputRef}
                placeholder="ÎåìÍ∏ÄÏùÑ ÎÇ®Í∏∞ÏÑ∏Ïöî..."
                value={commentText}
                onChange={(e) => setCommentText(e.target.value)}
                onFocus={handleCommentInputFocus}
                onKeyDown={(e) => {
                  if (e.key === "Enter" && !e.shiftKey) {
                    e.preventDefault();
                    handlePostComment();
                  }
                }}
              />
              {commentText.trim() && (
                <button
                  className={`${styles.postButton} ${
                    isLoggedIn
                      ? styles.postButtonActive
                      : styles.postButtonInactive
                  }`}
                  onClick={handlePostComment}
                  disabled={!isLoggedIn}
                >
                  Îì±Î°ù
                </button>
              )}
            </div>
          </div>
        </div>

        <div className={styles.commentsContainer} ref={commentsContainerRef}>
          {isLoading ? (
            <div style={{ textAlign: "center", padding: "20px" }}>
              Î°úÎî© Ï§ë...
            </div>
          ) : comments.length === 0 ? (
            <div className={styles.emptyComments}>
              <div className={styles.emptyCommentsIcon}>üí¨</div>
              <div className={styles.emptyCommentsText}>
                ÏïÑÏßÅ ÎåìÍ∏ÄÏù¥ ÏóÜÏäµÎãàÎã§
              </div>
              <div className={styles.emptyCommentsSubText}>
                Ï≤´ ÎåìÍ∏ÄÏùÑ ÎÇ®Í≤®Î≥¥ÏÑ∏Ïöî!
              </div>
            </div>
          ) : (
            <>
              {comments.map((comment) => (
                <React.Fragment key={comment.id}>
                  <div className={styles.commentItem}>
                    <div className={styles.profileImage}>
                      <img
                        src={
                          comment.profileImageUrl || "/api/placeholder/40/40"
                        }
                        alt="ÌîÑÎ°úÌïÑ"
                      />
                    </div>
                    <div className={styles.commentInfo}>
                      <div className={styles.profileName}>
                        {comment.profileName}
                      </div>
                      <div className={styles.content}>{comment.content}</div>
                      <div className={styles.commentActions}>
                        <span className={styles.timeStamp}>
                          {formatRelativeTime(comment.createdDate)}
                        </span>
                        <span>‚Ä¢</span>
                        <button className={styles.actionButton}>
                          Ï¢ãÏïÑÏöî {comment.likeCount}Í∞ú
                        </button>
                        <button
                          className={styles.actionButton}
                          onClick={() =>
                            handleReplyClick(comment.id, comment.profileName)
                          }
                        >
                          ÎãµÍ∏ÄÏì∞Í∏∞
                        </button>
                      </div>
                    </div>
                    <button
                      className={styles.likeButton}
                      onClick={() => handleToggleLike(comment.id)}
                    >
                      <Heart
                        size={16}
                        fill={comment.liked ? "#ff3040" : "none"}
                        color={comment.liked ? "#ff3040" : "currentColor"}
                      />
                    </button>
                  </div>

                  {comment.replies && comment.replies.length > 0 && (
                    <div className={styles.replySection}>
                      {comment.replies.map((reply) => (
                        <div className={styles.replyItem} key={reply.id}>
                          <div className={styles.profileImage}>
                            <img
                              src={
                                reply.profileImageUrl ||
                                "/api/placeholder/40/40"
                              }
                              alt="ÌîÑÎ°úÌïÑ"
                            />
                          </div>
                          <div className={styles.commentInfo}>
                            <div className={styles.profileName}>
                              {reply.profileName}
                            </div>
                            <div className={styles.content}>
                              <span className={styles.mentionText}>
                                @{comment.profileName}
                              </span>
                              {reply.content.replace(
                                `@${comment.profileName}`,
                                ""
                              )}
                            </div>
                            <div className={styles.commentActions}>
                              <span className={styles.timeStamp}>
                                {formatRelativeTime(reply.createdDate)}
                              </span>
                              <span>‚Ä¢</span>
                              <button className={styles.actionButton}>
                                Ï¢ãÏïÑÏöî {reply.likeCount}Í∞ú
                              </button>
                              <button
                                className={styles.actionButton}
                                onClick={() =>
                                  handleReplyClick(
                                    comment.id,
                                    reply.profileName
                                  )
                                }
                              >
                                ÎãµÍ∏ÄÏì∞Í∏∞
                              </button>
                            </div>
                          </div>
                          <button
                            className={styles.likeButton}
                            onClick={() => handleToggleLike(reply.id)}
                          >
                            <Heart
                              size={16}
                              fill={reply.liked ? "#ff3040" : "none"}
                              color={reply.liked ? "#ff3040" : "currentColor"}
                            />
                          </button>
                        </div>
                      ))}
                    </div>
                  )}
                </React.Fragment>
              ))}

              {isLoadingMore && (
                <div className={styles.loadingMore}>ÎåìÍ∏Ä Î∂àÎü¨Ïò§Îäî Ï§ë...</div>
              )}
            </>
          )}
        </div>
      </div>
    </>
  );

  // isOpenÏù¥ trueÏßÄÎßå Î°úÍ∑∏Ïù∏Ïù¥ ÎêòÏñ¥ ÏûàÏßÄ ÏïäÏùÄ Í≤ΩÏö∞ÏóêÎäî Î°úÍ∑∏Ïù∏ Î™®Îã¨Îßå ÌëúÏãú
  if (isOpen) {
    return ReactDOM.createPortal(
      <>
        {shouldShowCommentModal && commentModalContent}
        <LoginModal
          isOpen={isLoginModalOpen}
          onClose={handleLoginModalClose}
          message="ÎåìÍ∏Ä Í∏∞Îä•ÏùÄ Î°úÍ∑∏Ïù∏ ÌõÑ Ïù¥Ïö© Í∞ÄÎä•Ìï©ÎãàÎã§."
        />
      </>,
      document.body
    );
  }

  // Î™®Îã¨Ïù¥ Îã´ÌòÄÏûàÏúºÎ©¥ ÏïÑÎ¨¥Í≤ÉÎèÑ Î†åÎçîÎßÅÌïòÏßÄ ÏïäÏùå
  return null;
};

export default StyleComment;
